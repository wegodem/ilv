readint readreal ...

#include <stdio.h>
#include <math.h>
#include <curses.h>
#include <string.h>

#define Nstmax=16;
#define Nspmax=4;
#define pi = 3.1415926535897932; 
#define version = "           SUN ANSI C VERSION 1.0 - MAY 1995        ";

int     spinsystemdefined,rfpulsedefined,meanchoice,
        offsetsdefined,rotframe,batch,pulseflag,
        ap,ndw,ndx,ndy,ndz,i,Nspins,n,calc,npar,ncom;
double  h,ti,pt,x0,y0,z0,dx,dy,dz,gs,statoff;
double  cn[2],cn1[2],cn2[2],cn3[2],cn4[2],cn5[2],Eval[2],x[2];
double  densmat[16][16][2],Izee[16][16][2]  , Izgrad[16][16][2],
        Ixtot[16][16][2] , Iytot[16][16][2] ,
        Iztot[16][16][2] , Icoup[16][16][2] , Istat[16][16][2];
double  Ilist[16];
double  ket[16][16];
double  gx[512],gy[512],gz[512],xb[512],yb[512],offset[512];
double  jc[4][4];
double  par[160],pcom[160],xicom[160];

/* begin definition of function prototypes */
void Ispins();
void NonIntIspins();
void MakeBoltzmann();
void NonIntMakeBoltzmann();
void MakeZeeman();
void NonIntMakeZeeman();
void SpinSpinCoupling();
void NonIntSpinSpinCoupling();
void MakeGradientOperator();
void SetupSpins();
void init();
void DefinegradientOffset();
void DefinePulseHamiltonian();
void ReadBxByPulse();
void ReadBxBzPulse();
void LiouvilleInteractive();
void OutputPulse();
void Rotate3D();
void Rotate2D();
void B1Inhomogeneity();
void CalcExpVal();
void WriteIDL_BW_Header();
void ExpValNDensMat();
void ExpectationValueRotation();
void ExpectationOperator();
void MakeExpectationValueOperator();
void CreateOperators();
void CreateNormOperator();
void DecimalTo4Mal();
void OperatorExpectationValues();
void RedefinePulseHamiltonian();
void RedefineSpinSystem();
void TotalStartUp();
/*num recip voids*/
double fnc();
void dfnc();
void Optimize();
void StartOptimization();
void ParArrayToSignal();
void SignalToParArray();
void LiouvilleNonInteractive();
void Calculate2DPulseSequence();
void CalculatePulseSequence();
/*  end  definition of function prototypes */

void Ispins()
{ 
int k, Inumber; 
bool klaar; 
/*eold*/
  klaar = FALSE; 
  while ( NOT klaar) DO 
    klaar = TRUE; 
    for (k=1; k<=Nspmax; k++)
    { 
      Ilist[k] = 0
    } 
    REPEAT 
      printf("\n");
      printf( "Number of Spins = "); 
      ReadInt(Nspins); 
    UNTIL (Nspins <= Nspmax); 
    for (k=1;k<=Nspins;k++)
    { 
      printf("\n");
      printf( "I quantum number of spin("); 
      WriteInt( k,1); 
      printf( ") = x/2  with   x = "); 
      ReadInt(Inumber); 
      Ilist[k] = Inumber; 
    } 
    n = 1; 
    for (k=1;k<=Nspins;k++)
    { 
      n = (Ilist[k]+1)*n;
    } 
    printf("\n"); 
    if (n > Nstmax) 
    { 
      klaar = FALSE
    } 
  } 
  printf("n = ");
  WriteInt(n,8);
  printf("\n");
} 
/* end of void Ispins */

void NonIntIspins() 
{
int   k, Inumber; 
bool  klaar;
/* eold */
  
  ScreenMode(3);
  klaar = FALSE; 
  while ( NOT klaar) DO 
    klaar = TRUE; 
    for (k=1;k<=Nspmax;k++)
    { 
      Ilist[k]=0;
    }
    REPEAT 
      ReadInt(Nspins);
      printf("Number of spins                         : ");WriteInt(Nspins,3);printf("\n"); 
    UNTIL (Nspins <= Nspmax); 
    for (k=1;k<=Nspins;k++)
    { 
      ReadInt(Inumber); 
      Ilist[k] = Inumber; 
      printf( "I quantum number of spin("); WriteInt(k,1); 
      printf( ") = x/2 |   x : "); WriteInt(Ilist[k],3);printf("\n");
    } 
    n = 1; 
    for (k=1;k<=Nspins;k++)
    { 
      n = (Ilist[k]+1)*n
    } 
    printf("\n"); 
    if (n > Nstmax) 
    { 
      klaar = FALSE
    } 
  } 
  printf("Total number of states                  : ");WriteInt(n,2);printf("\n");
} 
/* end of void NonIntIspins */

void MakeBoltzmann() 
{
int i; 
double    gamma[2]; 
double    store[16][16][2]; 
bool      okay;
 
  CMatZero(n,densmat,densmat); 
  for (i=1;i<=Nspins;i++)
  { 
    CMatZero(n,store,store); 
    printf("\n");
    printf( "Relative Intensity of Spin ("); 
    WriteInt(i,1); 
    printf(")          : "); 
    ReadReal(gamma[1]);gamma[2]=0.0;
    MakeMatrixIz(Ilist,ket,n,i,store); 
    NormCMatrix(n,store); 
    CMultCMat(n,gamma,store,store); 
    CMatMultAdd(n,store,cn1,densmat,cn1,densmat); 
  }
} 
/* end of void MakeBoltzmann */

void NonIntMakeBoltzmann()
{
int    i; 
double gamma[2]; 
double store[16][16][2]; 
bool   okay;
/*eold*/
 
  CMatZero(n,densmat,densmat); 
  for (i=1;i<=Nspins;i++)
  { 
    CMatZero(n,store,store); 
    ReadReal(gamma[1]);gamma[2]=0.0;
    printf( "Relative Intensity of Spin ("); 
    WriteInt(i,1); 
    printf(")          : ");WriteReal(gamma[1],8);printf("\n");
    MakeMatrixIz(Ilist,ket,n,i,store); 
    NormCMatrix(n,store); 
    CMultCMat(n,gamma,store,store); 
    CMatMultAdd(n,store,cn1,densmat,cn1,densmat); 
  }
} 
/* end of void NonIntMakeBoltzmann */

void MakeZeeman() 
{
int    i; 
double gamma[2]; 
double store[16][16][2];
bool   okay;

  CMatZero(n,Izee,Izee); 
  for (i=1;i<=Nspins;i++)
  { 
    CMatZero(n,store,store); 
    printf("\n");
    printf( "Offset-frequency [Hz] of Spin("); 
    WriteInt(i,1); 
    printf(")        : "); 
    ReadReal(gamma[1]);gamma[2]=0.0;
    gamma[1]=gamma[1]*2.0*pi;
    MakeMatrixIz(Ilist,ket,n,i,store); 
    CMultCMat(n,gamma,store,store); 
    CMatMultAdd(n,store,cn1,Izee,cn1,Izee); 
  }
} 
/* end of void MakeZeeman */

void NonIntMakeZeeman()
{
int     i; 
double  gamma: COMPLEXLONGREAL; 
double  store: CMatrix; 
bool    okay:BOOLEAN;
/*eold*/     
  CMatZero(n,Izee,Izee); 
  for (i=1;i<=Nspins;i++)
  { 
    CMatZero(n,store,store); 
    ReadReal(gamma[1]);gamma[2]=0.0;
    printf( "Offset-frequency [Hz] of Spin ("); 
    WriteInt(i,1); 
    printf(")       : "); 
    WriteReal(gamma[1],8);printf("\n");
    gamma[1]=gamma[1]*2.0*pi;
    MakeMatrixIz(Ilist,ket,n,i,store); 
    CMultCMat(n,gamma,store,store); 
    CMatMultAdd(n,store,cn1,Izee,cn1,Izee); 
  }
} 
/* end of void NonIntMakeZeeman */

void SpinSpinCoupling()
{
double mat[16][16][2],mat1[16][16][2],mat2[16][16][2];
int    k,l,exact;
double j;
/*eold*/
  CMatZero(n,mat,mat);
  ScreenMode(3);
  if (Nspins > 1)
  {
    printf("*************************************\n");
    printf("***  Define J coupling constants  ***\n");
    printf("*************************************\n\n");
    printf("1. Weak-Coupling approximation. \n");
    printf("2. Exact calculation. \n");
    printf(" Your choice [1,2] : ");ReadInt(exact);printf("\n");
    printf("Give all Scalar coupling constants J(i,j)\n");
    printf("from the term J(i,j).I(i).S(j)\n\n");
    for (k=1;k<=Nspins;k++)
    {
      for(l=1;l<=Nspins;l++)
      {
        if (l>k) 
        {
          printf("Scalar Coupling Constant J(");WriteInt(k,1);
          printf(",");WriteInt(l,1);printf(")  = ");  
          ReadReal(jc[k,l]);printf("\n");printf("\n");
          j=2.0*jc[k,l]*pi; (* ! *)
          if (j != 0.0) 
          {
            printf("Calculating J.I(n).I(m)-TERM\n");
            if (exact!=1) 
            {
              (* *)
              MakeMatrixIx(Ilist,ket,n,k,mat1);
              MakeMatrixIx(Ilist,ket,n,l,mat2);
              CMatMult(n,mat1,mat2,mat1);
              RMultCMat(n,j,mat1,mat1);
              CMatAdd(n,mat1,mat,mat); 
              (* *)
              MakeMatrixIy(Ilist,ket,n,k,mat1);
              MakeMatrixIy(Ilist,ket,n,l,mat2);
              CMatMult(n,mat1,mat2,mat1);
              RMultCMat(n,j,mat1,mat1);
              CMatAdd(n,mat1,mat,mat); 
            }       
            MakeMatrixIz(Ilist,ket,n,k,mat1);
            MakeMatrixIz(Ilist,ket,n,l,mat2);
            CMatMult(n,mat1,mat2,mat1);
            RMultCMat(n,j,mat1,mat1);
            CMatAdd(n,mat1,mat,mat);
          }
        }
      }
    }
    CopyCMatrix(n,mat,Icoup);
  }
} 
/* end of void SpinSpinCoupling */

void NonIntSpinSpinCoupling()
{
double mat[16][16][2],mat1[16][16][2],mat2[16][16][2];
int    k,l,exact,dummy;
double j;
/*eold*/
  CMatZero(n,mat,mat);
  if (Nspins > 1) 
  {
    ReadInt(exact);
    ReadInt(dummy);
    for (k=1;k<=Nspins;k++)
    {
      for (l=1;l<=Nspins;l++)
      {
        if (l>k) 
        {
          ReadReal(jc[k,l]);
          printf("Scalar Coupling Constant J(");WriteInt(k,1);
          printf(",");WriteInt(l,1);printf(")         : ");
          WriteReal(jc[k,l],10);printf("\n");
          j=2.0*jc[k,l]*pi; (* ! *)
          if (j != 0.0) 
          {
            if (exact!=1) 
            {
              (* *)
              MakeMatrixIx(Ilist,ket,n,k,mat1);
              MakeMatrixIx(Ilist,ket,n,l,mat2);
              CMatMult(n,mat1,mat2,mat1);
              RMultCMat(n,j,mat1,mat1);
              CMatAdd(n,mat1,mat,mat); 
              (* *)
              MakeMatrixIy(Ilist,ket,n,k,mat1);
              MakeMatrixIy(Ilist,ket,n,l,mat2);
              CMatMult(n,mat1,mat2,mat1);
              RMultCMat(n,j,mat1,mat1);
              CMatAdd(n,mat1,mat,mat); 
            }       
            MakeMatrixIz(Ilist,ket,n,k,mat1);
            MakeMatrixIz(Ilist,ket,n,l,mat2);
            CMatMult(n,mat1,mat2,mat1);
            RMultCMat(n,j,mat1,mat1);
            CMatAdd(n,mat1,mat,mat);
          }
        }
      }
    }
    CopyCMatrix(n,mat,Icoup);
  }
} 
/* end of void NonIntSpinSpinCoupling */

void MakeGradientOperator()
{
int     i; 
double  gamma; 
double  store[16][16][2]; 
bool    okay;
/*eold*/ 
  CMatZero(n,Izgrad,Izgrad); 
  for (i=1;i<=Nspins;i++)
  { 
    CMatZero(n,store,store); 
    MakeMatrixIz(Ilist,ket,n,i,store); 
    CMatMultAdd(n,store,cn1,Izgrad,cn1,Izgrad); 
  }
} 
/* end of void MakeGradientOperator */

void SetupSpins()
{ 
  ScreenMode(3);printf("\n\n\n"); 
  printf("Definition of the spinsystem: \n");
  Ispins; 
  MakeKets(ket,Ilist); 
  MakeBoltzmann; 
} 
/* end of void SetupSpins */ 

void init()
{
  spinsystemdefined=0;rfpulsedefined=0;offsetsdefined=0;
  rotframe=0;
  batch=0;
  x0=0.0;dx=0.0;
  y0=0.0;dy=0.0;
  z0=0.0;dz=0.0;
  ndx=1;ndy=1;ndz=1;
  gs=0.0;ndw=1; (* default gradient setting *)
  calc=0;
  pulseflag=2;
  cn[1]=0.0;cn[2]=1.0;
  cn1[1]=1.0;cn1[2]=0.0;
  cn2[1]=0.5;cn2[2]=0.0;
  cn3[1]=2.0;cn3[2]=0.0;
  cn4[1]=1.0/6.0;cn4[2]=0.0;
  cn5[1]=-1.0;cn5[2]=0.0;
  CMatZero(n,densmat,densmat);
  CMatZero(n,Izee,Izee);
  CMatZero(n,Icoup,Icoup);
  CMatZero(n,Izgrad,Izgrad);
  CMatZero(n,Ixtot,Ixtot);
  CMatZero(n,Iytot,Iytot);
  CMatZero(n,Iztot,Iztot);
} 
/* end of void init */

void DefinegradientOffset()
{
  ScreenMode(3);printf("\n\n\n");
  printf("                *******************************\n");
  printf("                *** GRADIENT INITIALISATION ***\n");
  printf("                *******************************\n\n");
  MakeGradientOperator;
  printf("Define x-gradient : \n");
  printf("# offset-frequency points in x-direction : ");
  ReadInt(ndx);printf("\n");
  if (ndx==0) 
  { 
    ndx=1 
  }
  printf("The stepsize dx [cm]                     : ");
  ReadReal(dx);printf("\n");
  printf("Minimal x-coordinate x0 [cm]             : ");ReadReal(x0);
  printf("\n\n");
  CalcGrad(ap,h,gx);
  printf("\n\n");
  printf("Define y-gradient : \n");
  printf("# offset-frequency points in y-direction : ");
  ReadInt(ndy);printf("\n");
  if (ndy==0) 
  { 
    ndy=1 
  }
  printf("The stepsize dy [cm]                     : ");
  ReadReal(dy);printf("\n");
  printf("Minimal y-coordinate y0 [cm]             : ");ReadReal(y0);
  printf("\n\n");
  CalcGrad(ap,h,gy);
  printf("\n\n");
  printf("Define z-gradient : \n");
  printf("# offset-frequency points in z-direction : ");
  ReadInt(ndz);printf("\n");
  if (ndz==0) 
  { 
    ndz=1 
  }
  printf("The stepsize dz [cm]                     : ");
  ReadReal(dz);printf("\n");
  printf("Minimal z-coordinate z0 [cm]             : ");ReadReal(z0);
  printf("\n\n");
  CalcGrad(ap,h,gz);
  printf("\n\n");
} 
/* end of void DefinegradientOffset */

void DefinePulseHamiltonian()
{
int answer,hard;
/*eold*/ 
  ScreenMode(3);printf("\n\n\n"); 
  printf("            *****************************************\n");
  printf("            ***  DEFINITION OF PULSE HAMILTONIAN  ***\n");
  printf("            *****************************************\n");
  printf("\n\n");
  printf("Apply :");printf("\n\n");
  printf("        1. a standard hardpulse 90 or 180");printf("\n");
  printf("        2. another pulse");printf("\n\n");
  printf("Your choice [1,2] : ");ReadInt(hard);
  printf("\n");
  if (hard==1) 
  {
    pulseflag=0;
    ap=1;ti=1.0e-5;h=1.0e-5;(*both h and ti must have the same value!!*)
    AMHardPulseDefinition(ap,ti,xb,yb);
  }  
  else
  {  
    printf("What is the pulse time [ms]  : ");ReadReal(pt);
    pt=pt/1000.0;
    printf("\n\n");
    printf(" How many pulse-time intervals [-] : "); 
    ReadInt(ap);printf("\n\n");
    h=pt/FLOAT(ap);
    ti=pt/FLOAT(ap);
    printf("Pulse Hamiltonian type : \n\n");
    printf("     1. Hp(t) = f(t).Ix   (AM modulated) \n");
    printf("     2. Hp(t) = f(t).Ix + g(t).Iy (FM or adiabatic)\n")
    printf("     3. Pulse file (Bx,By) from disk\n");
    printf("     4. Pulse file (Bx,Bz) from disk\n");
    printf("\n");
    printf(" Your choice is [1..4] : ");
    ReadInt(answer);printf("\n");
    if (answer==1) 
    { 
      pulseflag=0;
    }
    if (answer==2) 
    { 
      pulseflag=1;
    }
    if (answer==3) 
    { 
      pulseflag=1;
    }
    if (answer==4) 
    { 
      pulseflag=1;
    }
    switch(answer)  
    {
      default:break;
            1:AMPulseDefinition(ap,ti,xb,yb);
              for (i=0;i<=ap-1;i++)
              {
                offset[i]=0.0;
              }
              break;
            2:FMPulseDefinition(ap,ti,xb,yb);            
              for(i=0;i<=ap-1;i++)
              {
                offset[i]=0.0;
              }
              break;
            3:ReadBxByPulse(ap,xb,yb,offset);
              break;
            4:ReadBxBzPulse(ap,xb,yb,offset);
              rotframe=1;
              break;
    }
  }
  printf("Static offset frequency of pulse : ");ReadReal(statoff);
  printf("\n");  
} 
/* end of void DefinePulseHamiltonian */

void ReadBxByPulse(ap, xb, yb, offset)
int    *ap;
double xb[],yb[],offset[];
{
int    i;
double mult;
/*eold*/
  printf("\n\n");
  printf("File name Bx(t)");
  RealArrayIn(ap,xb);
  printf("File name By(t)");
  RealArrayIn(ap,yb);
  printf("Multiplication constant : ");ReadReal(mult);printf("\n");
  for (i=0;i<=ap-1;i++)
  {
    xb[i]=xb[i]*mult;
    yb[i]=yb[i]*mult;
    offset[i]=0.0;
  }
}
/* end of void ReadBxByPulse */

void ReadBxBzPulse(ap:INTEGER;VAR xb,yb,offset:RArray)
int    *ap;
double xb[],yb[],offset[];
{
int    i;
double  mult;
/*eold*/
  printf("\n\n");
  printf("Name RF amplitude file Bx(t)\n");
  RealArrayIn(ap,xb);
  printf("Multiplication constant Bx(t) : ");ReadReal(mult);printf("\n");
  for (i=0;i<=ap-1;i++)
  {
    xb[i]=xb[i]*mult;
  } 
  printf("Name of RF offset frequency file dW(t)");printf("\n");
  RealArrayIn(ap,offset);
  printf("Multiplication constant dw(t) : ");ReadReal(mult);printf("\n");
  for (i=0;i<=ap-1;i++)
  {
    offset[i]=offset[i]*mult;
  } 
  for (i=0;i<=ap-1;i++)
  {
    yb[i]=0.0;
  }  
}
/* end of void ReadBxBzPulse */

void LiouvilleInteractive()
{
int  choice,choice1;
char chr;
  ScreenMode(3);printf(version);printf("\n");
  printf("This program integrates the Liouville von Neumann equations\n");
  printf("          d sigma / dt   = -i [ H , sigma ]");printf("\n\n");
  printf("Possible actions:\n\n");
  printf("     1. (Re)-Define a spin system\n");
  printf("     2. (Re)-Define a pulse Hamilton-operator\n");
  printf("     3. (Re)-Define a gradient-field etc. \n");
  printf("     4. Integrate using eigenvalue determination\n");
  printf("     5. spectral analyses\n");
  printf("     6. Determine expectation values of operator(-s) (-arrays).\n");
  printf("     7. Integrate using eigenvalue determination\n");
  printf("        and determining a time dependent expectation-\n");
  printf("        value of an arbitrary operator\n");
  printf("     8. Read / write binary files\n");
  printf("     9. Optimize RF Pulse \n");
  printf("    10. Effects B1-inhomogeneity\n");
  printf("    11. Store RF-pulse\n");
  printf("    12. Exit ilv\n\n");
  printf("Your choice is [1..12] : ");
  ReadInt(choice);printf("\n");
  if (choice!=12) 
  {
    switch(choice) 
    {
             default:break;
                   1:RedefineSpinSystem;
                     break;
                   2:RedefinePulseHamiltonian;
                     break;
                   3:DefinegradientOffset;
                     break;
                   4:Rotate3D;
                     CalcExpVal;break;
                   5:printf("Possibilities :\n");
                     printf("          1. calculate average spectrum \n");
                     printf("          2. calculate spectra seperately \n");
                     printf("Your choice [1,2] : ");ReadInt(choice1);printf("\n");
                     CMatAdd(n,Icoup,Izee,Istat);
                     MakeTotalIx(n,Nspins,ket,Ilist,TRUE,Ixtot);
                     MakeTotalIy(n,Nspins,ket,Ilist,TRUE,Iytot);
                     MakeTotalIz(n,Nspins,ket,Ilist,TRUE,Iztot);
                     ShowCMatElements(n,Iztot);
                     Read(chr);
                     if (choice1 == 1)
                     {
                       AverageSpectrum(n,ap,densmat,Istat,Ixtot,Iytot,Iztot,ket,Ilist); 
                     }  
                     else
                     {
                       SeparateSpectra(n,ap,densmat,Istat,Ixtot,Iytot,Iztot,ket,Ilist);
                     }
                     MakeTotalIx(n,Nspins,ket,Ilist,FALSE,Ixtot);
                     MakeTotalIy(n,Nspins,ket,Ilist,FALSE,Iytot);
                     MakeTotalIz(n,Nspins,ket,Ilist,FALSE,Iztot);
                     break;
                   6:OperatorExpectationValues;break;
                   7:ExpectationValueRotation;
                     CalcExpVal;
                     break;
                   8:BinFileActions(ndw,n);break;
                   9:Optimize;
                     break;
                  10:B1Inhomogeneity;
                     CalcExpVal;
                     break;               
                  11:OutputPulse;
                     break;
    }
    LiouvilleInteractive;
  }
} 
/* end of void LiouvilleInteractive */

void OutputPulse()
{
  printf("Output x-component RF-pulse \n");
  RealArrayOut(ap,xb);
  printf("Output y-component RF-pulse \n");
  RealArrayOut(ap,yb);
  printf("Output offset sweep of RF-pulse \n");
  RealArrayOut(ap,offset);
} 
/* end of void OutputPulse */

void Rotate3D()
{
double hc[16][16][2],hb[16][16][2],hs[16][16][2],ht[16][16][2],r[16][16][2];
double dw;
int     k,l,m,nz,dummy,j,ftype,fn,fndw;
int     written,read,nbytes,highpos,lowpos;
FILE    *inout,*out;
char    result;             /* was of type DirResult */
char    address1,address2;  /* was of type ADDRESS   */
char    done;               /* was of type BOOLEAN   */
/*eold*/
  if (pulseflag == 2) 
  {
    printf(">>>> NO RF-PULSE DEFINED ERROR <<<<\n");
  }
  else  
  {
    if (calc==0) 
    {
      Create(inout,"dm.bin",done);
      ndw=ndx*ndy*ndz;
      WriteBinFileHeader(inout,0,n,ndw); 
      nbytes=n*8*2;
      for (k=1;k<=(ndx*ndy*ndz);k++)
      {
        for (j=1;j<=n;j++)
        {        
          address1=ADR(densmat[j,1,1]);
          WriteNBytes(inout,address1,nbytes,written);          
          if (written != nbytes) 
          {
            printf(">>> WRITE BINARY-FILE ERROR <<<");
            Delay(1000);printf("\n");  
          }
        }     
      }
      Close(inout,done);
      CMatZero(n,densmat,densmat);
    }
    Open(inout,"dm.bin",ReadOnly,done); 
    ReadBinFileHeader(inout,ftype,fn,fndw);
    if ((ftype==0) && (fn==n) && (fndw==ndw)) 
    { 
      CMatAdd(n,Izee,Icoup,hc);    
      Create(out,"store",done);
      WriteBinFileHeader(out,0,n,ndw); 
      nbytes=n*8*2;
      for (k=1;k<=ndx;k++)
      {
        for (m=1;m<=ndy;m++)
        {
          for (nz=1;nz<=ndz;nz++)
          {
            CMatZero(n,r,r);
            for (j=1;j<=n;n++)
            {
              r[j,j,1]=1.0;
            }           
            for (j= 1;j<=n;j++)
            {
              address1=ADR(densmat[j,1,1]);
              ReadNBytes(inout,address1,nbytes,read);        
              if (read != nbytes) 
              {
                printf(">>> READ BINARY FILE ERROR <<<");Delay(1000);printf("\n");
              }
            }
            for (l=0;l<ap-1;l++)
            {
              dw=(x0+FLOAT(k-1)*dx)*gx[l];
              dw=dw+(y0+FLOAT(m-1)*dy)*gy[l];
              dw=dw+(z0+FLOAT(nz-1)*dz)*gz[l]+offset[l]+statoff;
              RMultCMat(n,dw,Izgrad,hs);
              CMatAdd(n,hc,hs,hs);
              RMultCMat(n,xb[l],Ixtot,ht);
              CMatAdd(n,hs,ht,hb);
              RMultCMat(n,yb[l],Iytot,ht);
              CMatAdd(n,ht,hb,hb);
              RMultCMat(n,-1.0,hb,hb);
              ExpMatrix(n,hb,h,hb);
              CMatMult(n,r,hb,r);      
            }
            DoRotation(n,r,densmat);
            for (j=1;j<=n;j++) 
            {
              address1=ADR(densmat[j,1,1]);       
              WriteNBytes(out,address1,nbytes,written);
              if (written != nbytes)
              {
                printf(">>> WRITE TO BINARY FILE ERROR <<<");Delay(1000);printf("\n");
              }
            }
            printf("*");          
          }
        }
      }    
      Close(inout,done);Close(out,done);
      Delete("dm.bin",result);
      Rename("store","dm.bin",result);
      calc=calc+1;
    }  
    else
    { 
      Close(inout,done);
      printf("Dimensions of dm.bin-file are : \n");
      WriteInt(ftype,5);WriteInt(fn,5);WriteInt(fndw,5);printf("\n");
      printf("Expected dimensions are : \n");
      WriteInt(0,5);WriteInt(n,5);WriteInt(ndw,5);printf("\n");
      printf(">>> NO CALCULATION <<<");ReadInt(dummy);      
    }
  }    
  ScreenMode(3);    
}
/* end of void Rotate3D */

void Rotate2D(n, ap, ndw, sectortype, h, statoff)
int    *n,*ap,*ndw,*sectortype;
double *h,*statoff;
/*eod*/
{
VAR    hc[16][16][2],hb[16][16][2],hs[16][16][2],ht[16][16][2],r[16][16][2];
double dw,dt;
int     k,l,m,nz,dummy,j,ftype,fn,fndw;
int     written,read,nbytes,highpos,lowpos;
FILE    *inout,*out;
char    result;            /* was of type DirResult */
char    address1,address2; /* was of type ADDRESS   */
char    done;              /* was of type boolean   */
char    chr;
/*eold*/
  if (pulseflag == 2) 
  {
    printf(">>>> NO RF-PULSE DEFINED ERROR <<<<\n");
  }  
  else
  {
    if (calc == 0) 
    {  
      Create(inout,"dm.bin",done);
      WriteBinFileHeader(inout,0,n,ndw); 
      nbytes=n*8*2;
      for (k=1;k<=ndw;k++)
      {
        for (j=1;j<=n;j++)
        {        
          address1=ADR(densmat[j,1,1]);
          WriteNBytes(inout,address1,nbytes,written);          
          if (written != nbytes) 
          {
            printf(">>> WRITE BINARY-FILE ERROR <<<");
            Delay(1000);printf("\n");  
          }
        }
      }
      Close(inout,done);
      CMatZero(n,densmat,densmat);
    }  
    else
    { 
      Open(inout,"dm.bin",ReadOnly,done); 
      ReadBinFileHeader(inout,ftype,fn,fndw);
      if (ndw!=fndw) 
      {
        Create(out,"store",done);
        WriteBinFileHeader(out,ftype,fn,ndw);
        nbytes=n*8*2;
        for (j=1;j<=n;j++)
        {
          address1=ADR(densmat[j,1,1]);
          ReadNBytes(inout,address1,nbytes,read);        
          if (read != nbytes)
          {
            printf(">>> READ BINARY FILE ERROR <<<");Delay(1000);printf("\n");
          }
        }
        for (k=1;k<=ndw;k++) 
        {
          for (j=1;j<=n;j++)
          {        
            address1=ADR(densmat[j,1,1]);
            WriteNBytes(out,address1,nbytes,written);          
            if (written != nbytes) 
            {
              printf(">>> WRITE BINARY-FILE ERROR <<<");
              Delay(1000);printf("\n");  
            }
          }     
        }
        Close(inout,done);Close(out,done);
        Delete("dm.bin",result);
        Rename("store","dm.bin",result);  
      }  
      else
      {
        Close(inout,done);
      }       
    }
    Open(inout,"dm.bin",ReadOnly,done); 
    ReadBinFileHeader(inout,ftype,fn,fndw);
    if ((ftype==0) && (fn==n) && (fndw==ndw))
    { 
      CMatAdd(n,Izee,Icoup,hc);    
      Create(out,"store",done);
      WriteBinFileHeader(out,0,n,ndw); 
      nbytes=n*8*2;
      for (k=1;k<=ndw;k++)
      {
        CMatZero(n,r,r);
        for (j=1;j<=n;j++)
        {
          r[j,j,1]=1.0;
        }           
        for (j=1;j<=n;j++)
        {
          address1=ADR(densmat[j,1,1]);
          ReadNBytes(inout,address1,nbytes,read);        
          if (read != nbytes) 
          {
            printf(">>> READ BINARY FILE ERROR <<<");Delay(1000);printf("\n");
          }
        }
        for (l=0;l<=ap-1;l++)
        {
          dw=statoff+offset[l];
          if (sectortype==2) 
          {
            dt=FLOAT(k)*h;
          }  
          else
          {
            dt=h;
          }    
          RMultCMat(n,dw,Izgrad,hs);
          CMatAdd(n,hc,hs,hs);
          RMultCMat(n,xb[l],Ixtot,ht);
          CMatAdd(n,hs,ht,hb);
          RMultCMat(n,yb[l],Iytot,ht);
          CMatAdd(n,ht,hb,hb);
          RMultCMat(n,-1.0,hb,hb);
          ExpMatrix(n,hb,dt,hb);
          CMatMult(n,r,hb,r);      
        }
        DoRotation(n,r,densmat);
        for (j=1;j<=n;j++)
        {
          address1=ADR(densmat[j,1,1]);       
          WriteNBytes(out,address1,nbytes,written);
          if (written != nbytes)
          {
            printf(">>> WRITE TO BINARY FILE ERROR <<<");Delay(1000);printf("\n");
          }
        }
        printf("*");        
      }
      Close(inout,done);Close(out,done);
      Delete("dm.bin",result);
      Rename("store","dm.bin",result);
      calc=calc+1;
    }  
    else
    { 
      Close(inout,done);
      printf("Dimensions of dm.bin-file are : \n");
      WriteInt(ftype,5);WriteInt(fn,5);WriteInt(fndw,5);printf("\n");
      printf("Expected dimensions are : ");printf("\n");
      WriteInt(0,5);WriteInt(n,5);WriteInt(ndw,5);printf("\n");
      printf(">>> NO CALCULATION <<<");ReadInt(dummy);      
    }
  }
  Delay(10000);    
  ScreenMode(3);    
} 
/* end of void Rotate2D */

void B1Inhomogeneity()
/***************************************************************/
/***  This procedure calculates the effects of B1-variation  ***/
/***  for a single offset frequency.                         ***/
/***************************************************************/
{
double hc[16][16][2],hs[16][16][2],ht[16][16][2],r[16][16][2];
double factor,dw,minfac,maxfac;
int    k,l,dummy,j,ftype,fn,fndw;
int    written,read,nbytes,highpos,lowpos;
FILE   *inout,*out;
char   address1,address2; /* were of type ADDRESS  */
char   result;            /* was of type DirResult */
char   done;              /* was of type BOOLEAN   */
double stx[257],sty[257];

  MakeGradientOperator();
  if (pulseflag == 2) 
  {
    printf(">>>> NO RF-PULSE DEFINED ERROR <<<<\n");    
  }  
  else
  {
    for (i=0;i<=ap-1;i++)
    { 
      stx[i]=xb[i];
      sty[i]=yb[i];
    }
    ScreenMode(3);
    printf("********************************************************************\n");
    printf("***        This part of the program integrates the equations     ***\n"); 
    printf("***  for a number of RF-amplitudes ,but single offset frequency: ***\n"); 
    printf("***                 B1[n] = B1[n]*multiplicationfactor           ***\n"); 
    printf("********************************************************************\n\n\n");
    printf("Number of RF amplitudes is : ");ReadInt(ndw);printf("\n"); 
    printf("Minimal multiplication factor : ");ReadReal(minfac);printf("\n");
    printf("Maximal multiplication factor : ");ReadReal(maxfac);printf("\n");  
    if (calc == 0)
    { 
      Create(inout,"dm.bin",done);
      WriteBinFileHeader(inout,0,n,ndw); 
      nbytes=n*8*2;
      for (k=1;k<=ndw;k++)
      {
        for (j=1;j<=n;j++)
        {        
          address1=ADR(densmat[j,1,1]);
          WriteNBytes(inout,address1,nbytes,written);          
          if (nbytes != written)
          {
            printf(">>> WRITE BINARY-FILE ERROR <<<\n");  
          }
        }     
      }
      Close(inout,done);
      CMatZero(n,densmat,densmat);
    }  
    Open(inout,"dm.bin",ReadOnly,done); 
    ReadBinFileHeader(inout,ftype,fn,fndw);
    if ((ftype==0) && (fn==n) && (fndw==ndw))
    { 
      CMatAdd(n,Izee,Icoup,hc);    
      Create(out,"store",done);
      WriteBinFileHeader(out,0,n,ndw); 
      nbytes=n*8*2;
      for (k=0;k<ndw-1;k++)
      {
        factor=minfac+FLOAT(k)*(maxfac-minfac)/(FLOAT(ndw-1)); 
        for (i=0;i<=ap-1;i++)
        {
          xb[i]=stx[i]*factor;
          yb[i]=sty[i]*factor;
        }
        CMatZero(n,r,r);
        for (j=1;j<=n;j++)
        {
          r[j,j,1]=1.0;
        }           
        for (j=1;j<=n;j++)
        {
          address1=ADR(densmat[j,1,1]);
          ReadNBytes(inout,address1,nbytes,read);        
          if (read != nbytes)
          {
            printf(">>> READ BINARY FILE ERROR <<<\n");
          }
        }
        for (l=0;l<=ap-1;l++)
        {
          dw=x0*gs+offset[l]+statoff;
          RMultCMat(n,dw,Izgrad,hs);
          CMatAdd(n,hc,hs,hs);
          RMultCMat(n,xb[l],Ixtot,ht);
          CMatAdd(n,hs,ht,hs);
          RMultCMat(n,yb[l],Iytot,ht);
          CMatAdd(n,ht,hs,hs);
          RMultCMat(n,-1.0,hs,hs);
          ExpMatrix(n,hs,h,hs);
          CMatMult(n,r,hs,r);      
        }
        DoRotation(n,r,densmat);
        for (j=1;j<=n;j++)
        {
          address1=ADR(densmat[j,1,1]);       
          WriteNBytes(out,address1,nbytes,written);
          if (nbytes != written)
          {
            printf(">>> WRITE TO BINARY FILE ERROR <<<\n");
          }
        }
        printf("*");          
      }
      Close(inout,done);Close(out,done);
      Delete("dm.bin",result);
      Rename("store","dm.bin",result);
      calc=calc+1;
    }  
    else
    {
      Close(inout,done);
      printf("Dimensions of dm.bin-file are : \n");
      WriteInt(ftype,5);WriteInt(fn,5);WriteInt(fndw,5);printf("\n");
      printf("Expected dimensions are : \n");
      WriteInt(0,5);WriteInt(n,5);WriteInt(ndw,5);printf("\n");
      printf(">>> NO CALCULATION <<<");ReadInt(dummy);      
    }
  } 
  for (i=0;i<=ap-1;i++)
  {
    xb[i]=stx[i];
    yb[i]=sty[i]; 
  } 
} 
/*end of void B1Inhomogeneity */

void CalcExpVal()
{
int dummy;
/*eold*/
  ScreenMode(3);
  printf("****************************************************\n");
  printf("***       CALCULATION OF EXPECTATION VALUES      ***\n");
  printf("****************************************************\n\n");
  printf("Possible actions :\n\n");
  printf("          1. Calculate expectation values of operators\n");
  printf("          2. Continue to main menu\n\n");
  printf("Your choice [1,2] : ");ReadInt(dummy);printf("\n");
  if (dummy!=2)
  {
    ExpValNDensMat();
    CalcExpVal();
  }
} 
/* end of void CalcExpVal */

void WriteIDL_BW_Header(out, nrij, nkol, nkan)
FILE out;
int  *nrij,*nkol,*nkan;
/*eod*/
{
char  lbarr[256];
int   labelsize,bpint;
char  address;   /* was of type ADDRESS  */
int   written;   /* was of type CARDINAL */
/*eold*/
  labelsize=256;
  bpint=4;
  lbarr[1]=*nrij;lbarr[2]=*nkol;lbarr[3]=*nkan;
  address=ADR(lbarr[1]);
  WriteNBytes(out,address,labelsize*bpint,written);
} 
/* end of void WriteIDL_BW_Header */

void ExpValNDensMat()
{
double store1[16][16][2],store2[16][16][2];
char   address,address1;              /* were of type ADDRESS */
FILE   *in,*out;
int    read,nbytes,written; 
int    i,j,dummy,ftype,fn,fndw,choice;
char   done;                          /* was of type BOOLEAN */
    lr:COMPLEXLONGREAL;
    chr:CHAR;
    fnm:ARRAY[0..12] OF CHAR;

  Open(in,"dm.bin",ReadOnly,done);
  ReadBinFileHeader(in,ftype,fn,fndw);
  nbytes=fn*8*2;
  ExpectationOperator(fn,Nspins,store1);
  printf("Create:  \n\n");
  printf("       1. SG-plot file \n");
  printf("       2. IDL file     \n\n");
  printf("Your choice [1,2] : ");ReadInt(choice);printf("\n");
  if (choice==1)
  {
    printf("SG-plot file naam : \n");
    OpenOutput("DAT");
  }
  else
  {
    printf("IDL-file name : ");ReadString(fnm);  
    Create(out,fnm,done);
    WriteIDL_BW_Header(out,ndx,ndy,ndz);
  }  
  address1=ADR(lr[1]);
  for(i=1;i<=fndw;i++)
  {
    for(j=1;j<=fn;j++)
    {
      address=ADR(store2[j,1,1]);
      ReadNBytes(in,address,nbytes,read);
      if (read != nbytes)
      {
        printf(">>> READ BINARY FILE ERROR <<<");Delay(1000);printf("\n");            
      }
    }  
    ExpectationValue(fn,store1,store2,lr); 
    if (choice==1) 
    {
      WriteCard(1,5);printf("   ");WriteReal(FLOAT(i),10);
      printf("   ");WriteReal(lr[1],18);printf("\n"); 
    }  
    else
    {
      WriteNBytes(out,address1,8,written);
    }  
  }
  Close(in,done);
  if (choice==1) 
  {
    CloseOutput;  
  }
  else
  {
    Close(out,done);
  }    
  printf("\n");
  printf("Last Expectation value : ");
  WriteReal(lr[1],18);printf("\n");
  printf("Press <Enter> to continue");
  Read(chr);
  printf("\n");
} 
/* end of void ExpValNDensMat */
    
void ExpectationValueRotation()
VAR hc,hb,hs,ht,oper:CMatrix;
    dw:REAL;
    inout,out:File;
    strtaddr1,strtaddr2,address1:ADDRESS;
    k,l,dummy,storedensmat,j,ftype,fn,fndw:INTEGER;
    written,nbytes,nbytes1,read:CARDINAL;
    lr:COMPLEXLONGREAL;
    done:BOOLEAN;
    result:DirResult;
{
  if (pulseflag == 2) 
  {
    printf(">>>> NO RF-PULSE DEFINED ERROR <<<<");printf("\n");
  }
  else
  {  
    nbytes=n*2*8; 
    if (calc == 0) 
    {
      printf("Creating new dm.bin  ...");Delay(1000);printf("\n"); 
      Create(inout,"dm.bin",done);
      WriteBinFileHeader(inout,0,n,ndw); 
      for (k=1;k<=ndw;k++)
      {
        for (j=1;j<=n;j++)
        {        
          address1=ADR(densmat[j,1,1]);
          WriteNBytes(inout,address1,nbytes,written);          
          if (written != nbytes)
          {
            printf(">>> WRITE BINARY-FILE ERROR <<<");Delay(1000);printf("\n");  
          }
        }
      }
      Close(inout,done);
    }
    CMatAdd(n,Izee,Icoup,hc);
    Open(inout,"dm.bin",ReadOnly,done);
    ReadBinFileHeader(inout,ftype,fn,fndw);
    if (fn==n) 
    { 
      Create(out,"store",done); 
      if (ndw==1)
      { 
        WriteBinFileHeader(out,2,n,ap);
      }  
      else
      {
        WriteBinFileHeader(out,0,n,ndw);
      }       
      for (k=1;k<=ndw;k++)
      {
        if (ndw!=1)
        {
          for (j=1;j<=n;j++)
          {
            address1=ADR(densmat[j,1,1]);
            ReadNBytes(inout,address1,nbytes,read);        
            if (read != nbytes)
            {
              printf(">>> READ BINARY FILE ERROR <<<");Delay(1000);printf("\n");
            }
          }
        }            
        for (l=0;l<=ap-1;l++)
        {
          dw=(x0+FLOAT(k-1)*dx)*gs+offset[l]+statoff;
          RMultCMat(n,dw,Izgrad,hs);
          CMatAdd(n,hc,hs,hs);
          RMultCMat(n,xb[l],Ixtot,ht);
          CMatAdd(n,hs,ht,hb);
          RMultCMat(n,yb[l],Iytot,ht);
          CMatAdd(n,ht,hb,hb);
          RMultCMat(n,-1.0,hb,hb);
          ExpMatrix(n,hb,h,hb);
          DoRotation(n,hb,densmat);
          if (ndw==1) 
          {
            for (i=1;i<=n;i++)
            {
              strtaddr2=ADR(densmat[i,1,1]);
              WriteNBytes(out,strtaddr2,nbytes,written);
              if (written != nbytes)
              { 
                printf("Write to Binary File Error");
              }   
            }
          }    
        }
        if (ndw!=1) 
        { 
          for (i=1;i<=n;i++)
          {
            strtaddr2=ADR(densmat[i,1,1]);
            WriteNBytes(out,strtaddr2,nbytes,written);
            if (written != nbytes)
            { 
              printf("Write to Binary File Error");
            }
          }
        }
      }
      Close(inout,done);
      Close(out,done);
      calc=calc+1;
      Delete("dm.bin",result);
      Rename("store","dm.bin",result);
    }
    else
    {
      CloseOutput;
      Close(inout,done);
      printf("Dimensions of dm.bin-file are : ");printf("\n");
      WriteInt(ftype,5);WriteInt(fn,5);WriteInt(fndw,5);printf("\n");
      printf("Expected dimensions are : ");printf("\n");
      WriteInt(0,5);WriteInt(n,5);WriteInt(ndw,5);printf("\n");
      printf(">>> NO EXPECTATION VALUES  <<<");ReadInt(dummy);      
    }  
  }
} 
/* end of void ExpectationValueRotation */

void ExpectationOperator(n,Nspins:INTEGER;VAR oper1:CMatrix)
VAR choice:INTEGER;
{
  ScreenMode(3);
  printf("*******************************************************\n");  
  printf("***   EXPECTATION VALUES OF AN ARBITRARY OPERATOR   ***\n");    
  printf("***                  OR PRODUCT OPERATOR            ***\n");
  printf("*******************************************************\n\n");
  printf("Define Operator : \n\n");
  printf("    1. Choose from a list (only valid for (multiple) spin 1/2 system\n");
  printf("    2. Create manually\n\n");
  printf("Your choice [1,2] : ");ReadInt(choice);
  if (choice==2) 
  {
    MakeExpectationValueOperator(n,oper1);
  }  
  else
  {
    CreateOperators(n,Nspins,oper1);
  }    
} 
/* end of void ExpectationOperator */

void MakeExpectationValueOperator(n:INTEGER;VAR oper1:CMatrix)
VAR oper,store1,store2,oper3:CMatrix;
    i,type,choice,choice1:INTEGER;
    lr:COMPLEXLONGREAL;
    mult:REAL;
{
  CMatZero(n,store1,store1);CMatZero(n,store2,store2);
  LOOP
    ScreenMode(3);
    printf("*******************************************************\n");  
    printf("***   EXPECTATION VALUES OF AN ARBITRARY OPERATOR   ***\n");    
    printf("***                  OR PRODUCT OPERATOR            ***\n");
    printf("*******************************************************\n\n");
    printf("Two operatators OPERATOR-1 and OPERATOR-2 can be defined\n");
    printf("These operators can be added or multiplied\n\n");
    printf("Possible actions : \n");
    printf("1 : Define OPERATOR-1 \n");
    printf("2 : Define OPERATOR_2 \n");
    printf("3 : OPERATOR-1 = OPERATOR-1 + OPERATOR-2 \n");
    printf("4 : OPERATOR-1 = OPERATOR-1 * OPERATOR-2 \n\n");
    printf("5 : Calculate expectation values of  OPERATOR-1\n");
    printf("Your choice [1..5]  : ");ReadInt(choice);printf("\n");
    if (choice == 3)
    {
      CMatAdd(n,store1,store2,store1);
    }
    if (choice == 4)
    { 
      CMatMult(n,store1,store2,store1);
      NormCMatrix(n,oper1);
    }
    if (choice == 5)
    { 
      EXIT;
    }
    if ((choice==1) || (choice = 2)) 
    {        
      CMatZero(n,oper,oper);CMatZero(n,oper1,oper1);
      LOOP
        printf("Spin number = ");ReadInt(i);printf("\n");
        printf("Give type of the operator I(type) : type = [1,2,3,4,5] : \n");
        printf(" TYPE 1 = x        TYPE 4 = + \n");
        printf(" TYPE 2 = y        TYPE 5 = - \n");
        printf(" TYPE 3 = z \n");        
        printf("(Be careful with non-hermitian operator types 4 and 5 !!\n");
        printf("Give type number : ");ReadInt(type);printf("\n");
        switch(type)
        {
              default:break; 
                    1:MakeMatrixIx(Ilist,ket,n,i,oper);
                      break;
                    2:MakeMatrixIy(Ilist,ket,n,i,oper);
                      break;
                    3:MakeMatrixIplus(Ilist,ket,n,i,oper);
                      MakeMatrixImin(Ilist,ket,n,i,oper3);
                      CMatCommutator(n,oper,oper3,oper);
                      RMultCMat(n,0.5,oper,oper);
                      break;
                    4:MakeMatrixIplus(Ilist,ket,n,i,oper);
                      break;
                    5:MakeMatrixImin(Ilist,ket,n,i,oper);
                      break;
        }
        NormCMatrix(n,oper);
        printf("1 = ADD to already existant operator\n");  
        printf("2 = MULTIPLY to the already existant operator\n\n");
        printf("Your choice [1,2] : ");ReadInt(type);printf("\n");
        CASE type OF
                    1:CMatAdd(n,oper,oper1,oper1);
                      break;
                    2:CMatMult(n,oper1,oper,oper1);
                      NormCMatrix(n,oper1);
        } 
        printf("\n\n");
        printf("Previous defined operator O.K. [1=yes,2=no] :  ");ReadInt(type);printf("\n");
        if (type==1) 
        {
          printf("Multiply Operator with a scalar [1=yes,2=no] :  ");
          ReadInt(choice1);printf("\n");
          if (choice1==1) 
          {
            printf("Multiplication factor : ");ReadReal(mult);printf("\n");
            RMultCMat(n,mult,oper1,oper1);
          }              
          EXIT;
        }  
      }
      if (choice == 1) 
      {
        CopyCMatrix(n,oper1,store1);
      }
      if (choice == 2) 
      { 
        CopyCMatrix(n,oper1,store2);
      }    
    }
  }
  CopyCMatrix(n,store1,oper1);
} 
/* end of void MakeExpectationValueOperator */


void CreateOperators(n,Nspins:INTEGER;VAR oper:CMatrix)
VAR count,i,j,sp,ntest,dummy,nlines,opno:INTEGER;
    symbolic,spinsymbol:ARRAY[0..4] OF CHAR;
    chr:CHAR;
{
  ScreenMode(3);
  switch(Nspins)
  {
    default:break;     
          1:printf("Spin(1) = I");
            spinsymbol[0]="I";
            break;
          2:spinsymbol[1]="S";spinsymbol[0]="I";
            printf("Spin(1) = I      Spin(2) = S");
            printf("\n\n");
            break;
          3:spinsymbol[2]="T";spinsymbol[1]="S";spinsymbol[0]="I";
            printf("Spin(1) = I      Spin(2) = S       Spin(3) = T");
            printf("\n\n");
            break;
          4:spinsymbol[3]="U";spinsymbol[2]="T";spinsymbol[1]="S";spinsymbol[0]="I";
            printf("Spin(1) = I      Spin(2) = S       Spin(3) = T      Spin(4) = U");
            printf("\n\n");
  }
  ntest=y1;nlines=1;
  for (j=1;j<=2*Nspins;j++)
  {
    ntest=ntest*2;
  }
  count=0;
  for (i=0;i<=ntest-1;i++)
  {
    INC(count);
    DecimalTo4Mal(i,symbolic);
    WriteInt(i,1); 
    if (i<10) 
    { 
      printf(" ") 
    }
    printf(". ");
    for (j=0;j<=Nspins-1;j++)
    {
      switch(j)
      {
      default: break; 
            0:if (symbolic[j] != "e") 
              { 
                printf(spinsymbol[0]) 
              }  
              else
              { 
                printf(" ");
              }
              break;
            1:if (symbolic[j] != "e")
              {
                printf(spinsymbol[1]) 
              }  
              else
              { 
                printf(" ");
              }
              break;
            2:if (symbolic[j] != "e")
              { 
                printf(spinsymbol[2]);
              }
              else
              { 
                printf(" ");
              }
              break;
            3:if (symbolic[j] != "e") 
              { 
                printf(spinsymbol[3]) 
              }
              else
              { 
                printf(" ");
              }
              break;
      }   
      if (symbolic[j] != "e") 
      { 
        Write(symbolic[j]) 
      {
      else
      {
        printf(" ");
      }    
    }
    printf("     ");
    if (count==4)
    {
      nlines=nlines+1;
      if (nlines==20) 
      { 
        printf("\n\n");
        printf("Press any key to continue : ");
        Read(chr);
        ScreenMode(3);nlines=1;
      }  
      printf("\n");
      count=0;
    }
  }
  printf("Enter operator number : ");ReadInt(opno);printf("\n");
  DecimalTo4Mal(opno,symbolic);
  CreateNormOperator(n,Nspins,symbolic,oper);
} 
/* end of void CreateOperators */

void CreateNormOperator(n,Nspins:INTEGER;symbolic:ARRAY OF CHAR;
                             VAR oper:CMatrix)
VAR store,store2:CMatrix;
    i,j:INTEGER;
{
  CMatZero(n,store,store);
  for (i=1;i<=Nspins;i++)
  {
    switch(symbolic[i-1]) 
    {
      default:break;
          "e":for (j=1;j<=n;j++) { store[j,j,1]=1.0; }
              break;
          "x":MakeMatrixIx(Ilist,ket,n,i,store);
              break;
          "y":MakeMatrixIy(Ilist,ket,n,i,store);
              break;
          "z":MakeMatrixIplus(Ilist,ket,n,i,store);
              MakeMatrixImin(Ilist,ket,n,i,store2);
              CMatCommutator(n,store,store2,store);
              RMultCMat(n,0.5,store,store);
              break;     
     }
     NormCMatrix(n,store);                           
     if (i==1) 
     {
       CopyCMatrix(n,store,oper);
     }
     else
     {   
       if (symbolic[i-1]!="e") 
       {
         CMatMult(n,oper,store,oper);
       }
     }
  }
  NormCMatrix(n,oper);
} 
/* end of void CreateNormOperator */

void DecimalTo4Mal(number:INTEGER;VAR vtal:ARRAY OF CHAR)
VAR i,rest,noper:INTEGER;
{
  for (i=0;i<=4;i++) { vtal[i]="e" }
  noper=1;
  LOOP
    if (number==0) 
    { 
      EXIT 
    }
    rest=(number MOD 4);
    number=(number DIV 4);
    switch (rest)
    {
      default: break;
            0: vtal[noper-1]="e";
               break;
            1: vtal[noper-1]="x";
               break;
            2: vtal[noper-1]="y";
               break;
            3: vtal[noper-1]="z";
               break;
    }
    noper=noper+1;  
  }
} 
/* end of void DecimalTo4Mal */

void OperatorExpectationValues()
VAR oper:CMatrix;
    i,type,k,dummy,ftype,fn,fndw:INTEGER;
    lr:COMPLEXLONGREAL;
    in:File;
    address:ADDRESS;
    read,nbytes:CARDINAL;
    done:BOOLEAN;
    x,y:ARRAY[0..512] OF REAL;
{
  ScreenMode(3);CMatZero(n,oper,oper);
  ExpectationOperator(n,Nspins,oper);
  nbytes=n*8*2;
  Open(in,"dm.bin",ReadOnly,done);
  ReadBinFileHeader(in,ftype,fn,fndw);
  for (k=1;k<=fndw;k++)
  {
    x[k]=FLOAT(k);
    for (i=1;i<=fn;i++)
    {
      address=ADR(densmat[i,1,1]);
      ReadNBytes(in,address,nbytes,read);
      if (read != nbytes) 
      {
        printf(">>> READ BINARY FILE ERROR <<<");Delay(1000);printf("\n");
      }
    }    
    ExpectationValue(n,oper,densmat,lr);
    printf("Real part of <Operator> ");
    WriteReal(lr[1],10);printf("\n");
    y[k]=lr[1];
    printf("Imaginary part of <Operator> ");WriteReal(lr[2],10);printf("\n\n");   
  }
  if (fndw > 1)
  {  
    tdplot1(x,y,ndw,1,2);
  }  
  else
  {
    printf(" no xyplot of one point ... ");ReadInt(dummy);
  }    
  Close(in,done);
  printf("Expectation value of an other operator [1=yes, 2=no] : ");
  ReadInt(type);printf("\n");  
  if (type == 1)
  { 
    OperatorExpectationValues;
  }
} 
/* end of OperatorExpectationValues */
    
void RedefinePulseHamiltonian()
VAR choice:INTEGER;
{
  DefinePulseHamiltonian;
  printf("More changes in Pulse Hamilton-operator [1=yes, 2=no] : ");
  ReadInt(choice);printf("\n");
  if (choice==1) 
  { 
    RedefinePulseHamiltonian;
  }
} 
/* end of RedefinePulseHamiltonian */

void RedefineSpinSystem()
VAR choice:INTEGER;
{
  ScreenMode(3);printf("\n\n");
  printf("*****************************************\n");
  printf("***    Definition of the spin system  ***\n");
  printf("*****************************************\n");
  printf("Possible actions : \n\n");
  printf("    1. total (re)-definition \n");
  printf("    2. change only Zeeman terms \n");
  printf("    3. change only scalar coupling constants \n");
  printf("    4. change only Zeeman terms & scalar coupling constants \n\n");
  printf("Your choice is [1..4] : ");ReadInt(choice);printf("\n");
  switch (choice)
  {
           default:break;
                 1:TotalStartUp;
                   break;
                 2:MakeZeeman;
                   break;
                 3:SpinSpinCoupling;
                   break;
                 4:MakeZeeman;
                   SpinSpinCoupling;
                   break;
  }
  printf("More changes of the spin system?  [1=yes, 2=no] : ");
  ReadInt(choice);
  if (choice == 1)
  {
    RedefineSpinSystem
  }
}
/* end of RedefineSpinSystem */

void TotalStartUp()
{
  SetupSpins;
  MakeZeeman;
  SpinSpinCoupling;
  MakeTotalIx(n,Nspins,ket,Ilist,FALSE,Ixtot);
  MakeTotalIy(n,Nspins,ket,Ilist,FALSE,Iytot);
  MakeTotalIz(n,Nspins,ket,Ilist,FALSE,Iztot);
} 
/* end of void TotalStartUp */

(*******************************************************************)
(***      THE FOLLOWING PROCEDURES ARE TAKEN FROM THE BOOK       ***)
(***     NUMERICAL RECIPES - THE ART OF SCIENTIFIC COMPUTING     ***)
(*** W.H. PRESS   B.P. FLANNERY   S.A. TEUKOLSKI W.T. VETTERLING ***)
(***   ISBN 0 521 30811 9   CAMBRIDGE UNIVERITY PRESS  (1986)    ***)
(*******************************************************************)


(*************************************************************************)
(**************      END OF PROCEDURES FROM NUMERICAL RECIPES    *********)
(*************************************************************************)

double fnc(VAR par:glnarray)
VAR i,j,l:INTEGER;
    hc,hs,ht,r,store:CMatrix;
    lr:COMPLEXLONGREAL;
    dw:REAL;
    x:ARRAY[0..64] OF REAL;
{
  for (i=0;i<=63;i++)
  {
    x[i]=FLOAT(i);
  }  
  CopyCMatrix(n,densmat,store);
  CMatAdd(n,Izee,Icoup,hc);
  ParArrayToSignal(npar,ap,par,xb,offset);
  CMatZero(n,r,r);
  for (i=1;i<=n;i++)
  {
    r[i,i,1]=1.0;
  }  
  for (i=0; i<=ap-1; i++)
  {
    dw=x0*gs+offset[i];
    RMultCMat(n,dw,Izgrad,hs); 
    CMatAdd(n,hc,hs,hs);
    RMultCMat(n,xb[i],Ixtot,ht);
    CMatAdd(n,hs,ht,hs);
    RMultCMat(n,-1.0,hs,hs);
    ExpMatrix(n,hs,h,hs);
    CMatMult(n,r,hs,r);
  }
  DoRotation(n,r,densmat);
  ExpectationValue(n,Istat,densmat,lr);   
  printf("Expectation Value dw norm is : ");WriteReal(lr[1],18);printf("\n");  
  CopyCMatrix(n,store,densmat);
  return lr[1];
} 
/*end of double fnc */

void dfnc(f1:REAL;VAR par,xi:glnarray)
VAR f2,store:REAL;
    i,ii:INTEGER;
{
  printf("*");printf("\n");
  for (i=0;i<=npar-1;i++)
  {
    if (par[i]!=0.0) 
    {
      store=par[i];
      par[i]=par[i]+(par[i]/1.0e7);
      f2=fnc(par);
      par[i]=par[i]-(store/1.0e7);
      xi[i]=(f2-f1)/(store/1.0e7);
    }  
    else
    {
      par[i]=1.0e-7;
      f2=fnc(par);
      par[i]=0.0;
      xi[i]=(f2-f1)/(1.0e-7);
    } 
  }     
} 
/*end of void dfnc */

void Optimize()
VAR dummy:CHAR;
    x:ARRAY[0..128] OF REAL;
    i:INTEGER;
{
  ScreenMode(3);
  printf("   ********************************************************\n");
  printf("   ***        OPTIMIZATION OF A PULSE RESPONCE          ***\n");
  printf("   ***        FOR A N-SPIN SYSTEM AND A GIVEN           ***\n");
  printf("   ***            INITIAL PULSE SEQUENCE                ***\n");
  printf("   ********************************************************\n");
  printf("   ***  sun ansi c version 1.0  amsm uni bern may 1995  ***\n");
  printf("   ********************************************************\n\n\n");
  printf("INFORMATION :");printf("\n");
  printf("Given a: 1. spin system with coupling constants\n");
  printf("         2. RF - pulse Hamiltionian\n");
  printf("         3. a Zeeman Hamiltionian\n");
  printf("         4. an operator O whose expectation value <O>\n");
  printf("            has to be optimized\n\n");
  printf("this part of the program calculates a RF-pulse Hamiltionian\n");
  printf("which optimizes the expectation value <O>\n");           
  printf("Now you will be prompted to define [1,2,3,4]\n");
  printf("Press any key to continue\n");
  Read(dummy);
  RedefineSpinSystem;
  RedefinePulseHamiltonian;
  ScreenMode(3);printf("\n");
  printf("Define operator whose expectation value is to be optimized : \n");
  Delay(3000);
  ExpectationOperator(n,Nspins,Istat);
  printf("The number of parameters is : ");
  ReadInt(npar);printf("\n");
  npar=4*npar;
  SignalToParArray(npar,ap,xb,offset,par);
  MakeGradientOperator;(* define Izgrad *)
  StartOptimization;
}
/* end of void Optimize */

void StartOptimization()
VAR i,coef,niter,dummy:INTEGER;
    minimum:REAL;
{
  frprmn(par,npar,3.0e-5,niter,minimum);
  printf("Btr(t)| out        >> \n\n");
  RealArrayOut(ap,xb);
  printf("Offset dw(t) out    >> \n\n");
  RealArrayOut(ap,offset);
} 
/* end of void StartOptimization */

void ParArrayToSignal(npar,ap:INTEGER;par:glnarray;
                      VAR rb1,rbz:RArray)
(*************************************************************************)
(***  THIS PROCEDURE TRANSFORMS THE RELEVANT npar COMPLEX FOURIER      ***)
(***  COEFFICIENTS TO AN ap POINT PULSE ARRAY IN THE TIME DOMAIN       ***)
(***  THE ARRAY real AND imaginary ARE EXPECTED TO CONTAIN ALSO        ***)
(***  FOURIER COEFFICIENTS. THE glnarr par IS CONSTRUCTED AS FOLLOWS   ***)
(***  {RFreal[0],RFimaginary[0], ... ,RFreal[npar],RFimaginary[npar]}  ***)
(***  CONTAINING THE FOURIER COEFFICIENTS OF THE RF PULSE              ***)
(***  DATE 14-09-1991 BY H.S.                                          ***)
(*************************************************************************)
VAR np,j,hap,i,ii:INTEGER;
    imag:ARRAY [0..256] OF REAL;
{
  np=(npar DIV 4);
  hap=ap DIV 2; 
  for (i=0;i<=ap-1;i++)
  {
    imag[i]=0.0;
  }   
  fft(ap,rb1,imag,FALSE); (* CALCULATES FFT OF B1 OF RF PULSE TIME SIGNAL *)
  for (j=0;j<=np-1;j++)
  {
    ii=2*j;
    rb1[hap+j]=par[ii];
    rb1[hap-j]=rb1[hap+j];
    imag[hap+(j+1)]=par[ii+1];
    imag[hap-(j+1)]=-imag[hap+(j+1)];
  }
  fft(ap,rb1,imag,TRUE); (* CALCULATES IFFT OF B1 OF RF PULSE SPECTRUM *)
  
  for (i=0;i<=ap-1;i++)
  {
    imag[i]=0.0;
  }   
  fft(ap,rbz,imag,FALSE); (* CALCULATES FFT OF FM OF RF PULSE TIME SIGNAL *)
  for (j=0;j<=np-1;j++)
  {
    ii=2*j;
    rbz[hap+j]=par[ii+2*np];
    rbz[hap-j]=rbz[hap+j];
    imag[hap+(j+1)]=par[ii+1+2*np];
    imag[hap-(j+1)]=-imag[hap+(j+1)];
  }
  fft(ap,rbz,imag,TRUE); (* CALCULATES IFFT OF FM OF RF PULSE SPECTRUM *)
} 
/* end of void ParArrayToSignal */


void SignalToParArray(npar,ap:INTEGER;
                      rb1,rbz:RArray;VAR par:glnarray)
VAR np,j,hap,i,ii:INTEGER;
    imag:ARRAY [0..256] OF REAL;
    
{
  np=(npar DIV 4);
  for (i= 0;i<=ap-1;i++)
  {
    imag[i]=0.0;
  }  
  hap=ap DIV 2;
  fft(ap,rb1,imag,FALSE); (* CALCULATES THE FFT OF B1 TIME SIGNAL *)
  for (j=0;j<=np-1;j++)
  {
    ii=2*j;
    par[ii]=rb1[hap+j];
    par[ii+1]=imag[hap+(j+1)];
  }  
  for (i=0;i<=ap-1;i++)
  {
    imag[i]=0.0;
  }  
  fft(ap,rbz,imag,FALSE); (* CALCULATES THE FFT OF FM TIME SIGNAL *)
  for (j=0;j<=np-1;j++)
  {
    ii=2*j+2*np;
    par[ii]=rbz[hap+j];
    par[ii+1]=imag[hap+(j+1)];
  }
} 
/* end of void SignalToParArray */

(******************************************************************)
(******************************************************************)

void LiouvilleNonInteractive()
VAR choice,choice1:INTEGER;
    done:BOOLEAN;
    chr:CHAR;
{
  ScreenMode(3);
  printf("    ****************************************************\n");
  printf("    ***  Solve Liouville von Neuman Non-Interactive  ***\n"); 
  printf("    ****************************************************\n");
  printf("Possibilities : \n\n");
  printf("               1. compose or change a pulse sequence\n");
  printf("               2. load and calculate a pulse sequence\n");
  printf("               3. load and calculate 1D/2D NMR pulse sequence\n");
  printf("               4. calculate expectation values\n");
  printf("               5. calculate spectra.\n");
  printf("               6. show pulse sequence file names in this directory\n");
  printf("               7. quit ilv\n\n");
  printf("Your choice [1..7] : ");ReadInt(choice);printf("\n");
  if (choice < 7) 
  {
    switch(choice)
    {
          default:break;
                1:ComposePulseSequence;
                  break;
                2:CalculatePulseSequence;
                  break;
                3:Calculate2DPulseSequence;
                  break;
                4:CalcExpVal;
                  break;
                5:printf("Possibilities : \n");
                  printf("          1. calculate average spectrum \n");
                  printf("          2. calculate spectra seperately \n");
                  printf("Your choice [1,2] : ");ReadInt(choice1);printf("\n");
                  CMatAdd(n,Icoup,Izee,Istat);
                  MakeTotalIx(n,Nspins,ket,Ilist,TRUE,Ixtot);
                  MakeTotalIy(n,Nspins,ket,Ilist,TRUE,Iytot);
                  if (choice1 == 1) 
                  { 
                    AverageSpectrum(n,ap,densmat,Istat,Ixtot,Iytot,Iztot,ket,Ilist); 
                  }
                  else
                  {
                    SeparateSpectra(n,ap,densmat,Istat,Ixtot,Iytot,Iztot,ket,Ilist);
                  }
                  MakeTotalIx(n,Nspins,ket,Ilist,FALSE,Ixtot);
                  MakeTotalIy(n,Nspins,ket,Ilist,FALSE,Iytot);
                  break;
                6:ScreenMode(3);
                  Run("C:\DOS\D.COM","*.SEQ",done);
                  printf("Press any key to continue \n")
                  Read(chr);
                  break;
    }
    LiouvilleNonInteractive;
  }   
} 
/* end of void LiouvilleNonInteractive */

void Calculate2DPulseSequence()
VAR dummy:ARRAY[0..20] OF CHAR;
    remark:ARRAY[0..31] OF CHAR;
    nbytes,nsect,i,sequencetype,sectortype,sector:INTEGER;
    read:CARDINAL;
    pfile:ARRAY[0..7] OF CHAR;
    flnm,flnm1:String;
    copy:ARRAY[0..15] OF CHAR;
    in:File;
    address:ADDRESS;
    done,simulation2D:BOOLEAN;
    char,chr:CHAR;
    result:DirResult;
{
  ScreenMode(3);
  simulation2D=FALSE;
  pulseflag=1;
  OpenInput("SEQ");
  ReadString(dummy);ReadInt(sequencetype);
  NonIntIspins;
  MakeKets(ket,Ilist);
  NonIntMakeBoltzmann;
  NonIntMakeZeeman;
  NonIntSpinSpinCoupling;
  MakeTotalIx(n,Nspins,ket,Ilist,FALSE,Ixtot);
  MakeTotalIy(n,Nspins,ket,Ilist,FALSE,Iytot);
  MakeTotalIz(n,Nspins,ket,Ilist,FALSE,Iztot);
  MakeGradientOperator;
  ReadInt(nsect);
  printf("Number of pulse sectors to calculate    : ");
  WriteInt(nsect,5);printf("\n");
  for (i=1;i<=nsect;i++)
  {
    ReadString(dummy);ReadInt(sector);
    printf("Calculating sector                      : ");WriteInt(sector,5);printf("\n");
    ReadString(dummy);ReadInt(sectortype);
    printf("Sector type                             : ");WriteInt(sectortype,5);printf("\n");
    ReadString(dummy);ReadInt(ap);
    printf("Number of time intervals in this sector : ");WriteInt(ap,5);printf("\n");
    ReadString(dummy);ReadInt(ndw);
    printf("Number of (evolution) intervals         : ");WriteInt(ndw,5);printf("\n");
    ReadString(dummy);ReadReal(pt);
    printf("Sector or pulsetime                [ms] : ");WriteReal((pt*1000.0),18);printf("\n");
    h=pt/FLOAT(ap);ti=h;
    ReadString(dummy);ReadString(pfile);
    printf("Reading pulse file                      :  ");printf(pfile);printf("\n");
    Open(in,pfile,ReadOnly,done);
    nbytes=ap*8;
    address=ADR(xb[0]);
    ReadNBytes(in,address,nbytes,read);
    address=ADR(yb[0]);
    ReadNBytes(in,address,nbytes,read);
    address=ADR(offset[0]);
    ReadNBytes(in,address,nbytes,read);
    Close(in,done);
    ReadString(dummy);ReadReal(statoff);
    printf("Reading pulse file                      :  ");WriteReal(statoff,18);printf("\n");
    statoff=statoff*2.0*pi;
    ReadString(dummy);ReadString(remark);
    printf("Remark on sector : ");
    printf(remark);printf("\n");
    Rotate2D(n,ap,ndw,sectortype,h,statoff);
    if (sectortype == 2)
    {
      simulation2D=TRUE;
    }  
  }
  ReadString(flnm);
  Concat("copy ","dm.bin",copy);
  DosCommand(copy,flnm,done);
  CloseInput;
  CMatAdd(n,Izee,Icoup,Istat);
  if (simulation2D=TRUE) 
  {
    MakeTotalIx(n,Nspins,ket,Ilist,TRUE,Ixtot);
    MakeTotalIy(n,Nspins,ket,Ilist,TRUE,Iytot);
    Determine2DSpectrum(n,ap,densmat,Istat,Ixtot,Iytot,Izgrad,ket,Ilist);
    MakeTotalIx(n,Nspins,ket,Ilist,FALSE,Ixtot);
    MakeTotalIy(n,Nspins,ket,Ilist,FALSE,Iytot);
  }  
} 
/* end of void Calculate2DPulseSequence */

void CalculatePulseSequence()
VAR dummy:ARRAY[0..20] OF CHAR;
    sequencetype,nbytes,nsect,i:INTEGER;
    read:CARDINAL;
    pfile:ARRAY[0..7] OF CHAR;
    flnm:ARRAY[0..11] OF CHAR;
    copy:ARRAY[0..15] OF CHAR;
    in:File;
    address:ADDRESS;
    done:BOOLEAN;
    char:CHAR;
    xas:ARRAY[0..129] OF REAL;
{
  ScreenMode(3);
  pulseflag=1;
  OpenInput("SEQ");
  ReadString(dummy);ReadInt(sequencetype);
  NonIntIspins;
  MakeKets(ket,Ilist);
  NonIntMakeBoltzmann;
  NonIntMakeZeeman;
  NonIntSpinSpinCoupling;
  MakeTotalIx(n,Nspins,ket,Ilist,FALSE,Ixtot);
  MakeTotalIy(n,Nspins,ket,Ilist,FALSE,Iytot);
  MakeTotalIz(n,Nspins,ket,Ilist,FALSE,Iztot);
  MakeGradientOperator; 
  ReadInt(ndx);ReadInt(ndy);ReadInt(ndz);
  printf("# x-direction : ");WriteInt(ndx,5);
  printf(" # y-direction : ");WriteInt(ndy,5);
  printf(" # z-direction : ");WriteInt(ndz,5);printf("\n");
  ReadInt(nsect);
  printf("Number of pulse sectors to calculate      : ");
  WriteInt(nsect,5);printf("\n");
  for (i=1;i<=nsect;i++)
  {
    printf("Calculating sector                      : ");WriteInt(i,5);printf("\n");
    ReadString(dummy);ReadString(dummy);
    ReadString(dummy);ReadInt(ap);
    printf("Number of time intervals in this sector : ");WriteInt(ap,5);printf("\n");
    ReadString(dummy);ReadReal(pt);
    printf("Sector or pulsetime                [ms] : ");WriteReal(pt*1000.0,12);printf("\n");
    h=pt/FLOAT(ap);ti=h;
    ReadString(dummy);ReadString(pfile);
    printf("Reading pulse file                      : ");printf(pfile);printf("\n");
    Open(in,pfile,ReadOnly,done);
    nbytes=ap*8;
    address=ADR(xb[0]);
    ReadNBytes(in,address,nbytes,read);
    address=ADR(yb[0]);
    ReadNBytes(in,address,nbytes,read);
    address=ADR(offset[0]);
    ReadNBytes(in,address,nbytes,read);
    address=ADR(gx[0]);
    ReadNBytes(in,address,nbytes,read);
    address=ADR(gy[0]);
    ReadNBytes(in,address,nbytes,read);
    address=ADR(gz[0]);
    ReadNBytes(in,address,nbytes,read);
    Close(in,done);
    ReadString(dummy);ReadReal(statoff);
    statoff=statoff*2.0*pi;    
    ReadString(dummy);ReadReal(x0);     
    printf("Spatial starting point x-direction [cm] : ");
    WriteReal(x0,15);printf("\n");
    ReadString(dummy);ReadReal(dx);     
    printf("Spatial x-stepsize                 [cm] : ");
    WriteReal(dx,15);printf("\n");
    ReadString(dummy);ReadReal(y0);     
    printf("Spatial starting point y-direction [cm] : ");
    WriteReal(y0,15);printf("\n");
    ReadString(dummy);ReadReal(dy);     
    printf("Spatial y-stepsize                 [cm] : ");
    WriteReal(dy,15);printf("\n");
    ReadString(dummy);ReadReal(z0);     
    printf("Spatial starting point z-direction [cm] : ");
    WriteReal(z0,15);printf("\n");
    ReadString(dummy);ReadReal(dz);     
    printf("Spatial z-stepsize                 [cm] : ");
    WriteReal(dz,15);printf("\n");
    ReadString(dummy);ReadString(dummy);
    printf("Remark : ");printf(dummy);printf("\n\n");
    Rotate3D;
  }       
  ReadString(flnm);
  Concat("copy ","dm.bin",copy);
  DosCommand(copy,flnm,done);
  CloseInput;
}
/* end of void CalculatePulseSequence */

int main()
{
  n=Nstmax;
  init;
  ScreenMode(3);
  printf("\n\n\n\n\n");
  printf("********************************************************************\n");
  printf("*           Integrate the Liouville Van Neumann Equations          *\n");
  printf("*                     ansi c  version 1.0 may 1995                 *\n");
  printf("*                          amsm uni bern                           *\n");
  printf("********************************************************************n\");
  printf("\n\n");
  Delay(2000);
  ScreenMode(3);
  printf("      *********************************************************\n");
  printf("      ***    Integrate the Liouville Von Neumann Equations  ***\n");
  printf("      *********************************************************\n\n");
  printf("Possibilities : \n\n");
  printf("          1. Solve Liouville Von Neuman Equations interactive\n");
  printf("          2. Solve Liouville Von Neuman Equations non interactive\n\n");
  printf("Your choice [1,2] : ");ReadInt(meanchoice);
  printf("\n\n");
  if (meanchoice==1) 
  {
    LiouvilleInteractive;
  }
  else
  {
    LiouvilleNonInteractive;
  }
}
